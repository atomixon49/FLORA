"""
FLORA Vulnerability Scanner
Escáner de vulnerabilidades para código y dependencias
"""

import os
import json
import subprocess
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from enum import Enum
from pathlib import Path
import re
import ast
import sys

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class VulnerabilitySeverity(Enum):
    """Severidad de vulnerabilidades"""
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class VulnerabilityType(Enum):
    """Tipos de vulnerabilidades"""
    SECURITY = "security"
    DEPENDENCY = "dependency"
    CODE_QUALITY = "code_quality"
    CONFIGURATION = "configuration"
    CRYPTOGRAPHY = "cryptography"

@dataclass
class Vulnerability:
    """Vulnerabilidad detectada"""
    vuln_id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    vuln_type: VulnerabilityType
    file_path: str
    line_number: Optional[int]
    code_snippet: Optional[str]
    cwe_id: Optional[str]
    cve_id: Optional[str]
    fix_suggestion: str
    references: List[str]
    detected_by: str
    timestamp: datetime

@dataclass
class ScanReport:
    """Reporte de escaneo de vulnerabilidades"""
    scan_id: str
    target_path: str
    start_time: datetime
    end_time: datetime
    total_files_scanned: int
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    info_count: int
    vulnerabilities: List[Vulnerability]
    summary: str
    recommendations: List[str]

class VulnerabilityScanner:
    """Escáner de vulnerabilidades"""
    
    def __init__(self, target_path: str):
        self.target_path = Path(target_path)
        self.vulnerabilities = []
        self.scanned_files = 0
        
        # Patrones de vulnerabilidades conocidas
        self.security_patterns = {
            "hardcoded_secrets": {
                "pattern": r'(?i)(password|secret|key|token|api_key)\s*=\s*["\'][^"\']+["\']',
                "severity": VulnerabilitySeverity.HIGH,
                "description": "Secreto hardcodeado detectado"
            },
            "sql_injection": {
                "pattern": r'execute\s*\(\s*["\'].*%s.*["\']',
                "severity": VulnerabilitySeverity.HIGH,
                "description": "Posible inyección SQL"
            },
            "command_injection": {
                "pattern": r'(os\.system|subprocess\.call|subprocess\.run)\s*\(\s*["\'].*\+.*["\']',
                "severity": VulnerabilitySeverity.HIGH,
                "description": "Posible inyección de comandos"
            },
            "path_traversal": {
                "pattern": r'open\s*\(\s*["\'][^"\']*\.\./[^"\']*["\']',
                "severity": VulnerabilitySeverity.MEDIUM,
                "description": "Posible path traversal"
            },
            "weak_crypto": {
                "pattern": r'(md5|sha1|des|rc4)\s*\(',
                "severity": VulnerabilitySeverity.MEDIUM,
                "description": "Algoritmo criptográfico débil"
            },
            "insecure_random": {
                "pattern": r'random\.(random|randint|choice)',
                "severity": VulnerabilitySeverity.MEDIUM,
                "description": "Generador de números aleatorios inseguro"
            },
            "debug_code": {
                "pattern": r'(print\s*\(|console\.log|debugger)',
                "severity": VulnerabilitySeverity.LOW,
                "description": "Código de debug en producción"
            },
            "eval_usage": {
                "pattern": r'eval\s*\(',
                "severity": VulnerabilitySeverity.HIGH,
                "description": "Uso de eval() detectado"
            },
            "exec_usage": {
                "pattern": r'exec\s*\(',
                "severity": VulnerabilitySeverity.HIGH,
                "description": "Uso de exec() detectado"
            },
            "pickle_usage": {
                "pattern": r'pickle\.(loads?|dumps?)',
                "severity": VulnerabilitySeverity.MEDIUM,
                "description": "Uso de pickle detectado (riesgo de deserialización)"
            }
        }
        
        # Patrones de configuración insegura
        self.config_patterns = {
            "debug_enabled": {
                "pattern": r'DEBUG\s*=\s*True',
                "severity": VulnerabilitySeverity.MEDIUM,
                "description": "Modo debug habilitado en producción"
            },
            "cors_wildcard": {
                "pattern": r'CORS_ALLOW_ORIGINS\s*=\s*["\']\*["\']',
                "severity": VulnerabilitySeverity.MEDIUM,
                "description": "CORS configurado con wildcard"
            },
            "secret_key_weak": {
                "pattern": r'SECRET_KEY\s*=\s*["\'][^"\']{1,20}["\']',
                "severity": VulnerabilitySeverity.HIGH,
                "description": "SECRET_KEY demasiado corto"
            },
            "insecure_headers": {
                "pattern": r'X-Frame-Options\s*=\s*["\']DENY["\']',
                "severity": VulnerabilitySeverity.LOW,
                "description": "Headers de seguridad no configurados"
            }
        }
    
    def scan_comprehensive(self) -> ScanReport:
        """Ejecutar escaneo completo de vulnerabilidades"""
        logger.info(f"Iniciando escaneo de vulnerabilidades en {self.target_path}")
        start_time = datetime.now()
        
        # Escanear archivos Python
        self._scan_python_files()
        
        # Escanear archivos de configuración
        self._scan_config_files()
        
        # Escanear dependencias
        self._scan_dependencies()
        
        # Escanear archivos de Docker
        self._scan_docker_files()
        
        end_time = datetime.now()
        
        # Generar reporte
        report = self._generate_report(start_time, end_time)
        
        logger.info(f"Escaneo completado. {len(self.vulnerabilities)} vulnerabilidades encontradas")
        return report
    
    def _scan_python_files(self):
        """Escanear archivos Python"""
        python_files = list(self.target_path.rglob("*.py"))
        
        for file_path in python_files:
            if self._should_skip_file(file_path):
                continue
                
            self.scanned_files += 1
            logger.debug(f"Escaneando archivo Python: {file_path}")
            
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    lines = content.split('\n')
                
                # Escanear patrones de seguridad
                self._scan_content_patterns(file_path, content, lines, self.security_patterns)
                
                # Análisis AST para vulnerabilidades complejas
                self._scan_ast_patterns(file_path, content)
                
            except Exception as e:
                logger.warning(f"Error al escanear {file_path}: {e}")
    
    def _scan_config_files(self):
        """Escanear archivos de configuración"""
        config_files = []
        config_files.extend(self.target_path.rglob("*.env"))
        config_files.extend(self.target_path.rglob("*.ini"))
        config_files.extend(self.target_path.rglob("*.cfg"))
        config_files.extend(self.target_path.rglob("*.conf"))
        config_files.extend(self.target_path.rglob("settings.py"))
        config_files.extend(self.target_path.rglob("config.py"))
        
        for file_path in config_files:
            if self._should_skip_file(file_path):
                continue
                
            self.scanned_files += 1
            logger.debug(f"Escaneando archivo de configuración: {file_path}")
            
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    lines = content.split('\n')
                
                # Escanear patrones de configuración
                self._scan_content_patterns(file_path, content, lines, self.config_patterns)
                
            except Exception as e:
                logger.warning(f"Error al escanear {file_path}: {e}")
    
    def _scan_dependencies(self):
        """Escanear vulnerabilidades en dependencias"""
        requirements_files = list(self.target_path.rglob("requirements*.txt"))
        requirements_files.extend(self.target_path.rglob("pyproject.toml"))
        requirements_files.extend(self.target_path.rglob("Pipfile"))
        
        for req_file in requirements_files:
            if self._should_skip_file(req_file):
                continue
                
            self.scanned_files += 1
            logger.debug(f"Escaneando dependencias: {req_file}")
            
            try:
                # Usar safety para escanear dependencias
                self._scan_with_safety(req_file)
                
                # Escanear versiones desactualizadas
                self._scan_outdated_packages(req_file)
                
            except Exception as e:
                logger.warning(f"Error al escanear dependencias en {req_file}: {e}")
    
    def _scan_docker_files(self):
        """Escanear archivos Docker"""
        docker_files = list(self.target_path.rglob("Dockerfile*"))
        docker_files.extend(self.target_path.rglob("docker-compose*.yml"))
        docker_files.extend(self.target_path.rglob("docker-compose*.yaml"))
        
        for docker_file in docker_files:
            if self._should_skip_file(docker_file):
                continue
                
            self.scanned_files += 1
            logger.debug(f"Escaneando archivo Docker: {docker_file}")
            
            try:
                with open(docker_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    lines = content.split('\n')
                
                # Patrones específicos de Docker
                docker_patterns = {
                    "root_user": {
                        "pattern": r'USER\s+root',
                        "severity": VulnerabilitySeverity.MEDIUM,
                        "description": "Contenedor ejecutándose como root"
                    },
                    "latest_tag": {
                        "pattern": r'FROM\s+\w+:latest',
                        "severity": VulnerabilitySeverity.LOW,
                        "description": "Uso de tag 'latest' en imagen base"
                    },
                    "exposed_ports": {
                        "pattern": r'EXPOSE\s+\d+',
                        "severity": VulnerabilitySeverity.LOW,
                        "description": "Puertos expuestos en contenedor"
                    },
                    "secrets_in_dockerfile": {
                        "pattern": r'(password|secret|key|token)\s*=\s*["\'][^"\']+["\']',
                        "severity": VulnerabilitySeverity.HIGH,
                        "description": "Secreto en Dockerfile"
                    }
                }
                
                self._scan_content_patterns(docker_file, content, lines, docker_patterns)
                
            except Exception as e:
                logger.warning(f"Error al escanear {docker_file}: {e}")
    
    def _should_skip_file(self, file_path: Path) -> bool:
        """Determinar si un archivo debe ser omitido"""
        skip_patterns = [
            '__pycache__',
            '.git',
            '.venv',
            'venv',
            'env',
            '.env',
            'node_modules',
            '.pytest_cache',
            'build',
            'dist',
            '.mypy_cache',
            '.coverage'
        ]
        
        file_str = str(file_path)
        return any(pattern in file_str for pattern in skip_patterns)
    
    def _scan_content_patterns(self, file_path: Path, content: str, lines: List[str], patterns: Dict[str, Dict]):
        """Escanear contenido con patrones regex"""
        for pattern_name, pattern_info in patterns.items():
            matches = re.finditer(pattern_info["pattern"], content, re.MULTILINE)
            
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                line_content = lines[line_number - 1] if line_number <= len(lines) else ""
                
                vuln = Vulnerability(
                    vuln_id=f"{pattern_name}_{file_path.name}_{line_number}",
                    title=pattern_info["description"],
                    description=f"Patrón inseguro detectado: {pattern_name}",
                    severity=pattern_info["severity"],
                    vuln_type=VulnerabilityType.SECURITY,
                    file_path=str(file_path),
                    line_number=line_number,
                    code_snippet=line_content.strip(),
                    cwe_id=self._get_cwe_for_pattern(pattern_name),
                    cve_id=None,
                    fix_suggestion=self._get_fix_suggestion(pattern_name),
                    references=self._get_references(pattern_name),
                    detected_by="regex_pattern",
                    timestamp=datetime.now()
                )
                
                self.vulnerabilities.append(vuln)
    
    def _scan_ast_patterns(self, file_path: Path, content: str):
        """Escanear código usando análisis AST"""
        try:
            tree = ast.parse(content)
            
            for node in ast.walk(tree):
                # Detectar uso de eval()
                if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'eval':
                    vuln = Vulnerability(
                        vuln_id=f"eval_usage_{file_path.name}_{node.lineno}",
                        title="Uso de eval() detectado",
                        description="eval() puede ejecutar código arbitrario",
                        severity=VulnerabilitySeverity.HIGH,
                        vuln_type=VulnerabilityType.SECURITY,
                        file_path=str(file_path),
                        line_number=node.lineno,
                        code_snippet=content.split('\n')[node.lineno - 1].strip(),
                        cwe_id="CWE-95",
                        cve_id=None,
                        fix_suggestion="Usar ast.literal_eval() o validación de entrada",
                        references=["https://cwe.mitre.org/data/definitions/95.html"],
                        detected_by="ast_analysis",
                        timestamp=datetime.now()
                    )
                    self.vulnerabilities.append(vuln)
                
                # Detectar uso de exec()
                elif isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'exec':
                    vuln = Vulnerability(
                        vuln_id=f"exec_usage_{file_path.name}_{node.lineno}",
                        title="Uso de exec() detectado",
                        description="exec() puede ejecutar código arbitrario",
                        severity=VulnerabilitySeverity.HIGH,
                        vuln_type=VulnerabilityType.SECURITY,
                        file_path=str(file_path),
                        line_number=node.lineno,
                        code_snippet=content.split('\n')[node.lineno - 1].strip(),
                        cwe_id="CWE-95",
                        cve_id=None,
                        fix_suggestion="Evitar exec() o usar validación estricta",
                        references=["https://cwe.mitre.org/data/definitions/95.html"],
                        detected_by="ast_analysis",
                        timestamp=datetime.now()
                    )
                    self.vulnerabilities.append(vuln)
                
                # Detectar hardcoded secrets en asignaciones
                elif isinstance(node, ast.Assign):
                    for target in node.targets:
                        if isinstance(target, ast.Name) and target.id.lower() in ['password', 'secret', 'key', 'token', 'api_key']:
                            if isinstance(node.value, ast.Constant) and isinstance(node.value.value, str):
                                vuln = Vulnerability(
                                    vuln_id=f"hardcoded_secret_{file_path.name}_{node.lineno}",
                                    title="Secreto hardcodeado detectado",
                                    description=f"Variable {target.id} contiene valor hardcodeado",
                                    severity=VulnerabilitySeverity.HIGH,
                                    vuln_type=VulnerabilityType.SECURITY,
                                    file_path=str(file_path),
                                    line_number=node.lineno,
                                    code_snippet=content.split('\n')[node.lineno - 1].strip(),
                                    cwe_id="CWE-798",
                                    cve_id=None,
                                    fix_suggestion="Usar variables de entorno o gestor de secretos",
                                    references=["https://cwe.mitre.org/data/definitions/798.html"],
                                    detected_by="ast_analysis",
                                    timestamp=datetime.now()
                                )
                                self.vulnerabilities.append(vuln)
        
        except SyntaxError:
            logger.warning(f"Error de sintaxis en {file_path}, omitiendo análisis AST")
        except Exception as e:
            logger.warning(f"Error en análisis AST de {file_path}: {e}")
    
    def _scan_with_safety(self, req_file: Path):
        """Usar safety para escanear dependencias"""
        try:
            result = subprocess.run(
                ['safety', 'check', '--json', '--file', str(req_file)],
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                # No hay vulnerabilidades
                return
            
            try:
                safety_data = json.loads(result.stdout)
                for vuln in safety_data:
                    vuln_obj = Vulnerability(
                        vuln_id=f"safety_{vuln.get('package_name', 'unknown')}_{vuln.get('installed_version', 'unknown')}",
                        title=f"Vulnerabilidad en {vuln.get('package_name', 'paquete')}",
                        description=vuln.get('advisory', 'Vulnerabilidad conocida'),
                        severity=VulnerabilitySeverity.HIGH if vuln.get('severity') == 'high' else VulnerabilitySeverity.MEDIUM,
                        vuln_type=VulnerabilityType.DEPENDENCY,
                        file_path=str(req_file),
                        line_number=None,
                        code_snippet=None,
                        cwe_id=None,
                        cve_id=vuln.get('cve'),
                        fix_suggestion=f"Actualizar a versión {vuln.get('specs', 'más reciente')}",
                        references=vuln.get('more_info_url', []),
                        detected_by="safety",
                        timestamp=datetime.now()
                    )
                    self.vulnerabilities.append(vuln_obj)
            except json.JSONDecodeError:
                logger.warning(f"No se pudo parsear salida de safety para {req_file}")
        
        except subprocess.TimeoutExpired:
            logger.warning(f"Timeout al escanear dependencias en {req_file}")
        except FileNotFoundError:
            logger.warning("Safety no está instalado. Instalar con: pip install safety")
        except Exception as e:
            logger.warning(f"Error al ejecutar safety en {req_file}: {e}")
    
    def _scan_outdated_packages(self, req_file: Path):
        """Escanear paquetes desactualizados"""
        try:
            result = subprocess.run(
                ['pip', 'list', '--outdated', '--format=json'],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                outdated_packages = json.loads(result.stdout)
                for pkg in outdated_packages:
                    vuln = Vulnerability(
                        vuln_id=f"outdated_{pkg['name']}",
                        title=f"Paquete desactualizado: {pkg['name']}",
                        description=f"Versión actual: {pkg['version']}, última: {pkg['latest_version']}",
                        severity=VulnerabilitySeverity.LOW,
                        vuln_type=VulnerabilityType.DEPENDENCY,
                        file_path=str(req_file),
                        line_number=None,
                        code_snippet=None,
                        cwe_id=None,
                        cve_id=None,
                        fix_suggestion=f"Actualizar con: pip install --upgrade {pkg['name']}",
                        references=[],
                        detected_by="pip_list",
                        timestamp=datetime.now()
                    )
                    self.vulnerabilities.append(vuln)
        
        except subprocess.TimeoutExpired:
            logger.warning("Timeout al verificar paquetes desactualizados")
        except Exception as e:
            logger.warning(f"Error al verificar paquetes desactualizados: {e}")
    
    def _get_cwe_for_pattern(self, pattern_name: str) -> Optional[str]:
        """Obtener CWE ID para un patrón"""
        cwe_mapping = {
            "hardcoded_secrets": "CWE-798",
            "sql_injection": "CWE-89",
            "command_injection": "CWE-78",
            "path_traversal": "CWE-22",
            "weak_crypto": "CWE-327",
            "insecure_random": "CWE-330",
            "eval_usage": "CWE-95",
            "exec_usage": "CWE-95",
            "pickle_usage": "CWE-502"
        }
        return cwe_mapping.get(pattern_name)
    
    def _get_fix_suggestion(self, pattern_name: str) -> str:
        """Obtener sugerencia de corrección para un patrón"""
        fix_suggestions = {
            "hardcoded_secrets": "Usar variables de entorno o gestor de secretos",
            "sql_injection": "Usar consultas parametrizadas o ORM",
            "command_injection": "Usar subprocess con argumentos separados",
            "path_traversal": "Validar y sanitizar rutas de archivos",
            "weak_crypto": "Usar algoritmos criptográficos seguros (AES, SHA-256)",
            "insecure_random": "Usar secrets.SystemRandom() o os.urandom()",
            "eval_usage": "Usar ast.literal_eval() o validación de entrada",
            "exec_usage": "Evitar exec() o usar validación estricta",
            "pickle_usage": "Usar serialización segura como JSON o msgpack",
            "debug_enabled": "Deshabilitar DEBUG en producción",
            "cors_wildcard": "Especificar dominios permitidos explícitamente",
            "secret_key_weak": "Usar SECRET_KEY de al menos 32 caracteres",
            "root_user": "Usar usuario no-root en contenedores",
            "latest_tag": "Usar tags específicos de versión",
            "secrets_in_dockerfile": "Usar secretos de Docker o variables de entorno"
        }
        return fix_suggestions.get(pattern_name, "Revisar y corregir según mejores prácticas")
    
    def _get_references(self, pattern_name: str) -> List[str]:
        """Obtener referencias para un patrón"""
        references = {
            "hardcoded_secrets": ["https://cwe.mitre.org/data/definitions/798.html"],
            "sql_injection": ["https://cwe.mitre.org/data/definitions/89.html"],
            "command_injection": ["https://cwe.mitre.org/data/definitions/78.html"],
            "path_traversal": ["https://cwe.mitre.org/data/definitions/22.html"],
            "weak_crypto": ["https://cwe.mitre.org/data/definitions/327.html"],
            "eval_usage": ["https://cwe.mitre.org/data/definitions/95.html"],
            "exec_usage": ["https://cwe.mitre.org/data/definitions/95.html"],
            "pickle_usage": ["https://cwe.mitre.org/data/definitions/502.html"]
        }
        return references.get(pattern_name, [])
    
    def _generate_report(self, start_time: datetime, end_time: datetime) -> ScanReport:
        """Generar reporte de escaneo"""
        total_vulns = len(self.vulnerabilities)
        critical_count = len([v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL])
        high_count = len([v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.HIGH])
        medium_count = len([v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.MEDIUM])
        low_count = len([v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.LOW])
        info_count = len([v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.INFO])
        
        # Generar resumen
        if critical_count > 0:
            summary = f"CRÍTICO: {critical_count} vulnerabilidades críticas encontradas"
        elif high_count > 0:
            summary = f"ALTO: {high_count} vulnerabilidades de alta severidad encontradas"
        elif medium_count > 0:
            summary = f"MEDIO: {medium_count} vulnerabilidades de severidad media encontradas"
        elif total_vulns > 0:
            summary = f"BAJO: {total_vulns} problemas menores encontrados"
        else:
            summary = "EXCELENTE: No se encontraron vulnerabilidades"
        
        # Generar recomendaciones
        recommendations = []
        if critical_count > 0:
            recommendations.append("URGENTE: Corregir vulnerabilidades críticas inmediatamente")
        if high_count > 0:
            recommendations.append("ALTA PRIORIDAD: Abordar vulnerabilidades de alta severidad")
        if medium_count > 0:
            recommendations.append("MEDIA PRIORIDAD: Planificar corrección de vulnerabilidades medias")
        if total_vulns > 0:
            recommendations.append("Implementar escaneo de vulnerabilidades en CI/CD")
            recommendations.append("Establecer políticas de seguridad de código")
        else:
            recommendations.append("Mantener buenas prácticas de seguridad")
            recommendations.append("Continuar con escaneos regulares")
        
        return ScanReport(
            scan_id=f"VULNSCAN-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
            target_path=str(self.target_path),
            start_time=start_time,
            end_time=end_time,
            total_files_scanned=self.scanned_files,
            total_vulnerabilities=total_vulns,
            critical_count=critical_count,
            high_count=high_count,
            medium_count=medium_count,
            low_count=low_count,
            info_count=info_count,
            vulnerabilities=self.vulnerabilities,
            summary=summary,
            recommendations=recommendations
        )
    
    def save_report(self, report: ScanReport, filename: str = None):
        """Guardar reporte en archivo"""
        if filename is None:
            filename = f"vulnscan_report_{report.scan_id}.json"
        
        report_data = {
            "scan_id": report.scan_id,
            "target_path": report.target_path,
            "start_time": report.start_time.isoformat(),
            "end_time": report.end_time.isoformat(),
            "total_files_scanned": report.total_files_scanned,
            "total_vulnerabilities": report.total_vulnerabilities,
            "critical_count": report.critical_count,
            "high_count": report.high_count,
            "medium_count": report.medium_count,
            "low_count": report.low_count,
            "info_count": report.info_count,
            "summary": report.summary,
            "recommendations": report.recommendations,
            "vulnerabilities": [
                {
                    "vuln_id": v.vuln_id,
                    "title": v.title,
                    "description": v.description,
                    "severity": v.severity.value,
                    "vuln_type": v.vuln_type.value,
                    "file_path": v.file_path,
                    "line_number": v.line_number,
                    "code_snippet": v.code_snippet,
                    "cwe_id": v.cwe_id,
                    "cve_id": v.cve_id,
                    "fix_suggestion": v.fix_suggestion,
                    "references": v.references,
                    "detected_by": v.detected_by,
                    "timestamp": v.timestamp.isoformat()
                }
                for v in report.vulnerabilities
            ]
        }
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Reporte guardado en {filename}")

# Función de conveniencia
def scan_vulnerabilities(target_path: str) -> ScanReport:
    """Escanear vulnerabilidades en un directorio"""
    scanner = VulnerabilityScanner(target_path)
    return scanner.scan_comprehensive()

# Ejemplo de uso
if __name__ == "__main__":
    # Escanear vulnerabilidades
    report = scan_vulnerabilities(".")
    
    print(f"Reporte de Vulnerabilidades: {report.scan_id}")
    print(f"Resumen: {report.summary}")
    print(f"Archivos escaneados: {report.total_files_scanned}")
    print(f"Vulnerabilidades encontradas: {report.total_vulnerabilities}")
    print(f"Críticas: {report.critical_count}, Altas: {report.high_count}, Medias: {report.medium_count}")
    
    # Guardar reporte
    scanner = VulnerabilityScanner(".")
    scanner.save_report(report)
